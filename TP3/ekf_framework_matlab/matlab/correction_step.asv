function [mu_, sigma_] = correction_step(mu, sigma, z, l)
    % Updates the belief, i. e., mu and sigma, according to the sensor model
    %
    % The employed sensor model is range-only.
    %
    % mu: 3 x 1 vector representing the mean (x, y, theta) of the normal distribution
    % sigma: 3 x 3 covariance matrix of the normal distribution
    % z: structure containing the landmark observations, see
    %    read_data for the format
    % l: structure containing the landmark position and ids, see
    %    read_world for the format


    % Compute the expected range measurements.
    % This corresponds to the function h.
    % expected_ranges = zeros(size(z, 2), 1);
    % for i = 1:size(z, 2)
    %     % Todo: Implement
    %     expected_ranges = (l(i,1) - mu(1))^2 + (l(i,2) - mu(2))^2;
    % end

    % Jacobian of h
    H = zeros(size(z, 2), 3);

    mu_ = mu;
    sigma_ = sigma;
    R = diag(repmat(0.5, size(z, 2), 1));

    % Measurements in vectorized form
    Z = zeros(size(z, 2), 1);
    for i = 1:size(z, 2)

        j = z(i).id;            
        mx = l(j).x;
        my = l(j).y;

        dx = mx - mu(1);
        dy = my - mu(2);
        q = dx^2 + dy^2;
        H = [ -dx / sqrt(q), -dy / sqrt(q), 0;
              dy / q,       -dx / q,      -1 ];
        Z = [sqrt(q);
            atan2(dy, dx) - mu_(3)];
        S = H * sigma * H.' + R;
        K = sigma * H.' * inv(S);
        z_real = [z(i).range;
                  z(i).bearing];  

        mu_ = mu_ + K * (z_real - Z);
        sigma_ = (eye(3) - K * H) * sigma_;
    end
end
